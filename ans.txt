1. В Go, самым эффективным способом конкатенации строк является использование функции strings.Builder.
Причина эффективности strings.Builder состоит в том, что он использует один и тот же массив байтов для
конкатенации, что существенно уменьшает нагрузку на память и время выполнения

2. Интерфейсы в Go - это определенный тип, который описывает набор методов. Однако он не предоставляет реализаций
для этих методов - это должны делать типы, которые реализуют интерфейс. Интерфейсы в Go используются для обеспечения
полиморфизма. Если тип реализует интерфейс, мы можем использовать значения этого типа, как будто они являются
значениями интерфейса

3. Mutex предоставляет стандартные функции блокировки и разблокировки и используется для контроля доступа к ресурсу.
Он не позволяет одновременного выполнения больше, чем одной горутины.
RWMutex отличается тем, что он позволяет иметь множество горутин, которые могут выполняться одновременно,
если они только читают данные. Если горутина пытается записать данные (Lock), все остальные горутины будут заблокированы,
пока эта горутина не завершит свою работу (Unlock)

4. Небуферизированные каналы (или синхронные каналы) предоставляют возможность гарантировать, что операция отправки в
канал завершится только тогда, когда получатель получит данные из канала. Это означает, что если нет получателя,
отправка будет заблокирована.
Буферизированные каналы (или асинхронные каналы), с другой стороны, имеют внутренний буфер, который позволяет
отправителю отправлять определенное количество данных в канал без блокировки, даже если получатель еще не получил данные

5. Нулевой

6. Перегрузки методов или операторов нет

7. В случайном порядке

8. make(T, args) - используется только с slice, map и channel. Он возвращает инициализированный (не нулевой)
тип T (не указатель), который готов к использованию.
new(T) возвращает указатель на новый объект типа T, который инициализирован нулями (для его типа)

9. Объявление без инициализации, с инициализацией и make

10. 1 1. В функцию update передали копию переменной. Внутри функции ей присвоили адресна переменную, которая
актуальна в области видимости функции, но не в глобальной. Если переписать как *p = b, то значение поменяется b

11. Числа от 0 до 4 в рандомном порядке и deadlock. Ошибка с горутинами из-за передачи в горутину wg.
Сразу можно отметить, что i из цикла нужна в горутине, иначе цикл успеет добежать до последней итерации

12. 0. Т.к. внутри цикла if затенение переменной n

13. В функции меняется первый элемент на 100. В append добавляем значение в срез, где происходит увеличение и создание
нового базового массива, а из него и нового среза. Т.к. функция не возвращает значений, срез а в main() не меняется

14. В анонимной функции расширили срез за счет добавления элемента (новый родительский массив и слайс), потом поменяли
1 и 2 элементы на b, но уже в новом срезе. Если бы это была функция с return'ом, то возвращенный срез был бы изменённым





